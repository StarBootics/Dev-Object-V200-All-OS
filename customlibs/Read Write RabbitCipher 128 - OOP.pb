; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V1.2.0
; Project name : Read Write RabbitCipher
; File name : Read Write RabbitCipher 128 - OOP.pb
; File Version : 2.0.1
; Programmation : OK
; Programmed by : StarBootics
; Creation Date : Noverber 8th, 2020
; Last update : November 27th, 2021
; Coded for PureBasic : V6.00 Beta 1
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Programming notes
;
; 1. Rabbit was designed by Martin Boesgaard, Mette Vesterager, 
;    Thomas Pedersen, Jesper Christiansen and Ove Scavenius. 
;
;    https://www.ecrypt.eu.org/stream/rabbitpf.html
;
; 2. Type of Algorithm : Synchronous Stream Cipher 
;
; 3. Rabbit has been released into the public domain and may 
;    be used freely for any purpose.
; 
; 4. I deserve credit only for porting Rabbit Cipher from C to
;    PureBasic. I'm not the original designer of the algorithm
;    so no credit to me for that.
;
; 5. The software is provided "as is" without any express or 
;    implied warranty. You are using it at your own risk. The 
;    original authors and/or me shall not in any way be liable 
;    for any use of this software.
;
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule RabbitCipher

  Interface RabbitCipher
    
    GetKey.s()
    GetInitVector.s()
    SetKey(P_Key.s)
    SetInitVector(P_InitVector.s)
    RunSetup()
    
    RC_WriteString(FileID.i, P_String.s)
    RC_WriteByte(FileID.i, P_Value.b)
    RC_WriteAsciiCharacter(FileID.i, P_Value.a)
    RC_WriteWord(FileID.i, P_Value.w)
    RC_WriteUnicodeCharacter(FileID.i, P_Value.u)
    RC_WriteCharacter(FileID.i, P_Value.c)
    RC_WriteLong(FileID.i, P_Value.l)
    RC_WriteQuad(FileID.i, P_Value.q)
    RC_WriteInteger(FileID.i, P_Value.i)
    RC_WriteFloat(FileID.i, P_Value.f)
    RC_WriteDouble(FileID.i, P_Value.d)
    RC_WriteData(FileID.i, *Memory, Size.l) 
    
    RC_ReadString.s(FileID.i)
    RC_ReadByte.b(FileID.i)
    RC_ReadAsciiCharacter.a(FileID.i)
    RC_ReadWord.w(FileID.i)
    RC_ReadUnicodeCharacter.u(FileID.i)
    RC_ReadCharacter.c(FileID.i)
    RC_ReadLong.l(FileID.i)
    RC_ReadQuad.q(FileID.i)
    RC_ReadInteger.i(FileID.i)
    RC_ReadFloat.f(FileID.i)
    RC_ReadDouble.d(FileID.i)
    RC_ReadData(FileID.i, *Memory, Size.l)
    
    Free()
    
  EndInterface
  
  Declare.i New(P_Key.s = "RabbitCipher", P_InitVector.s = "InitVector")
  
EndDeclareModule

Module RabbitCipher
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structures declaration <<<<<
  
  Structure Rabbit
    
    X.q[8]
    C.q[8]
    Carry.q
    
  EndStructure
  
  Structure Temp
    
    g.q[8]
    OldC.q[8]
    
  EndStructure
  
  Structure Buffer
    
    Buffer.a[16]
    
  EndStructure
  
  Structure Core
    
    Master.Rabbit
    Work.Rabbit
    
  EndStructure
  
  Structure Private_Members
    
    VirtualTable.i
    Key.s
    InitVector.s
    IsSetupDone.i
    Core.Core
    
  EndStructure

  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Macros declaration <<<<<
  
  Macro U32V(v)
    
    ((v) & $FFFFFFFF)
    
  EndMacro
  
  Macro ROTL32(v, n)
    
    (U32V((v) << (n)) | ((v) >> (32 - (n))))
    
  EndMacro
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Procedures declaration (Private) <<<<<
  
  Procedure.i Normalizer(Input.s, BitsLength.l)
    
    Byte = BitsLength >> 3
    
    Output.s = StringFingerprint(Input, #PB_Cipher_MD5)
    
    *Normalized = AllocateMemory(Byte)
    *Cursor.Ascii = *Normalized
    
    For Index = 1 To Byte
      
      *Cursor\a = Val("$" + Mid(Output, Index, 2))
      *Cursor + SizeOf(Ascii)
      
    Next
    
    ProcedureReturn *Normalized
  EndProcedure
  
  Procedure.q PeekU32(*Buffer)
    
    ; Even if a quad size is 64-bit, we are
    ; interested only by the first 32-bit.
    
    CopyMemory(*Buffer, @Var.q, 4)
    
    ProcedureReturn Var
  EndProcedure
  
  Procedure PokeU32(*Buffer, Var.q)
    
    ; Even if a quad size is 64-bit, we are
    ; interested only by the first 32-bit.
    
    CopyMemory(@Var, *Buffer, 4)
    
  EndProcedure
  
  Procedure.q ReadU32(FileID.i)
    
    ReadData(FileID, @Var.q, 4)
    
    ProcedureReturn Var
  EndProcedure
  
  Procedure WriteU32(FileID.i, Var.q)
    
    WriteData(FileID, @Var, 4)
    
  EndProcedure
  
  Procedure.q U8TO32_LITTLE(*p)
    
    B0.a = PeekA(*p+0)
    B1.a = PeekA(*p+1)
    B2.a = PeekA(*p+2)
    B3.a = PeekA(*p+3)
    
    ProcedureReturn U32V(B0 | B1 << 8 | B2 << 16 | B3 << 24)
  EndProcedure
  
  Procedure.q Addition(VarA.q, VarB.q, VarC.q = 0)
    
    Result.q = U32V(VarA + VarB)
    Result = U32V(Result + VarC)
    
    ProcedureReturn Result
  EndProcedure
  
  Procedure.q RABBIT_GFunc(x.q)
    
    x * x
    
    ProcedureReturn U32V(x ! (x >> 32))
  EndProcedure
  
  Procedure RABBIT_NextState128(*Rabbit.Rabbit)
    
    ; Temporary variables
    Protected Temp.Temp, Index.l
    
    ; Save old counter values
    For Index = 0 To 7 
      Temp\OldC[Index] = *Rabbit\C[Index]
    Next
    
    ; Calculate new counter values
    *Rabbit\C[0] = Addition(*Rabbit\C[0], $4D34D34D + *Rabbit\Carry)
    *Rabbit\C[1] = Addition(*Rabbit\C[1], $D34D34D3 + Bool(*Rabbit\C[0] < Temp\OldC[0]))
    *Rabbit\C[2] = Addition(*Rabbit\C[2], $34D34D34 + Bool(*Rabbit\C[1] < Temp\OldC[1]))
    *Rabbit\C[3] = Addition(*Rabbit\C[3], $4D34D34D + Bool(*Rabbit\C[2] < Temp\OldC[2]))
    
    *Rabbit\C[4] = Addition(*Rabbit\C[4], $D34D34D3 + Bool(*Rabbit\C[3] < Temp\OldC[3]))
    *Rabbit\C[5] = Addition(*Rabbit\C[5], $34D34D34 + Bool(*Rabbit\C[4] < Temp\OldC[4]))
    *Rabbit\C[6] = Addition(*Rabbit\C[6], $4D34D34D + Bool(*Rabbit\C[5] < Temp\OldC[5]))
    *Rabbit\C[7] = Addition(*Rabbit\C[7], $D34D34D3 + Bool(*Rabbit\C[6] < Temp\OldC[6]))
    
    *Rabbit\Carry = Bool(*Rabbit\C[7] < Temp\OldC[7])
    
    ; Calculate the g-values
    
    For Index = 0 To 7
      Temp\g[Index] = RABBIT_GFunc(Addition(*Rabbit\X[Index], *Rabbit\C[Index]))
    Next
    
    ; Calculate new state values
    
    *Rabbit\X[0] = Addition(Temp\g[0], ROTL32(Temp\g[7],16), ROTL32(Temp\g[6], 16))
    *Rabbit\X[1] = Addition(Temp\g[1], ROTL32(Temp\g[0], 8), Temp\g[7])
    *Rabbit\X[2] = Addition(Temp\g[2], ROTL32(Temp\g[1],16), ROTL32(Temp\g[0], 16))
    *Rabbit\X[3] = Addition(Temp\g[3], ROTL32(Temp\g[2], 8), Temp\g[1])
    *Rabbit\X[4] = Addition(Temp\g[4], ROTL32(Temp\g[3],16), ROTL32(Temp\g[2], 16))
    *Rabbit\X[5] = Addition(Temp\g[5], ROTL32(Temp\g[4], 8), Temp\g[3])
    *Rabbit\X[6] = Addition(Temp\g[6], ROTL32(Temp\g[5],16), ROTL32(Temp\g[4], 16))
    *Rabbit\X[7] = Addition(Temp\g[7], ROTL32(Temp\g[6], 8), Temp\g[5])
    
  EndProcedure

  Procedure RABBIT_KeySetup128(*Core.Core, *Key)
    
    ; Temporary Variables
    Protected k0.q, k1.q, k2.q, k3.q, Index.l
    
    ; Generate four subkeys
    k0 = U8TO32_LITTLE(*Key + 0)
    k1 = U8TO32_LITTLE(*Key + 4)
    k2 = U8TO32_LITTLE(*Key + 8)
    k3 = U8TO32_LITTLE(*Key + 12)
    
    ; Generate initial state variables
    *Core\Master\X[0] = k0
    *Core\Master\X[2] = k1
    *Core\Master\X[4] = k2
    *Core\Master\X[6] = k3
    *Core\Master\X[1] = U32V(k3 << 16) | (k2 >> 16)
    *Core\Master\X[3] = U32V(k0 << 16) | (k3 >> 16)
    *Core\Master\X[5] = U32V(k1 << 16) | (k0 >> 16)
    *Core\Master\X[7] = U32V(k2 << 16) | (k1 >> 16)
    
    ; Generate initial counter values
    *Core\Master\C[0] = ROTL32(k2, 16)
    *Core\Master\C[2] = ROTL32(k3, 16)
    *Core\Master\C[4] = ROTL32(k0, 16)
    *Core\Master\C[6] = ROTL32(k1, 16)
    
    *Core\Master\C[1] = (k0 & $FFFF0000) | (k1 & $FFFF)
    *Core\Master\C[3] = (k1 & $FFFF0000) | (k2 & $FFFF)
    *Core\Master\C[5] = (k2 & $FFFF0000) | (k3 & $FFFF)
    *Core\Master\C[7] = (k3 & $FFFF0000) | (k0 & $FFFF)
    
    *Core\Master\Carry = 0
    
    ; Iterate the system four times
    
    For index = 0 To 3
      RABBIT_NextState128(*Core\Master)
    Next
    
    ; Modify the counters
    For Index = 0 To 7
      *Core\Master\C[Index] ! *Core\Master\X[(Index + 4) & 7]
    Next
    
    ; Copy master instance to work instance
    
    For Index = 0 To 7
      *Core\Work\X[Index] = *Core\Master\X[Index]
      *Core\Work\C[Index] = *Core\Master\C[Index]
    Next
    
    *Core\Work\Carry = *Core\Master\Carry
    
  EndProcedure
  
  Procedure RABBIT_InitVectorSetup128(*Core.Core, *InitVector)
    
    ; Temporary variables
    Protected i0.q, i1.q, i2.q, i3.q, Index.l
    
    ; Generate four subvectors
    i0 = U8TO32_LITTLE(*InitVector + 0)
    i2 = U8TO32_LITTLE(*InitVector + 4)
    i1 = (i0 >> 16) | (i2 & $FFFF0000)
    i3 = (i2 << 16) | (i0 & $0000FFFF)
    
    ; Modify counter values
    
    *Core\Work\C[0] = *Core\Master\C[0] ! i0
    *Core\Work\C[1] = *Core\Master\C[1] ! i1
    *Core\Work\C[2] = *Core\Master\C[2] ! i2
    *Core\Work\C[3] = *Core\Master\C[3] ! i3
    
    *Core\Work\C[4] = *Core\Master\C[4] ! i0
    *Core\Work\C[5] = *Core\Master\C[5] ! i1
    *Core\Work\C[6] = *Core\Master\C[6] ! i2
    *Core\Work\C[7] = *Core\Master\C[7] ! i3
    
    ; Copy state variables
    
    For Index = 0 To 7
      *Core\Work\X[Index] = *Core\Master\X[Index]
    Next
    
    *Core\Work\Carry = *Core\Master\Carry
    
    ; Iterate the system four times
    
    For index = 0 To 3
      RABBIT_NextState128(*Core\Work)
    Next
    
  EndProcedure

  Procedure RABBIT_Process_Bytes128(*Core.Core, *Input, *Output, MsgLen.l)
    
    ; Temporary variables 
    
    Protected Buffer.Buffer, Index.l
    
    ; Encrypt/decrypt all full blocks
    
    While MsgLen >= 16
      
      ; Iterate the system
      RABBIT_NextState128(*Core\Work)
      
      ; Encrypt/decrypt 16 bytes of data 
      PokeU32(*Output + 00, PeekU32(*Input + 00) ! *Core\Work\X[0] ! (*Core\Work\X[5] >> 16) ! U32V(*Core\Work\X[3] << 16))
      PokeU32(*Output + 04, PeekU32(*Input + 04) ! *Core\Work\X[2] ! (*Core\Work\X[7] >> 16) ! U32V(*Core\Work\X[5] << 16))
      PokeU32(*Output + 08, PeekU32(*Input + 08) ! *Core\Work\X[4] ! (*Core\Work\X[1] >> 16) ! U32V(*Core\Work\X[7] << 16))
      PokeU32(*Output + 12, PeekU32(*Input + 12) ! *Core\Work\X[6] ! (*Core\Work\X[3] >> 16) ! U32V(*Core\Work\X[1] << 16))
      
      *Input + 16
      *Output + 16
      MsgLen - 16
      
    Wend
    
    ; Encrypt/decrypt remaining data
    
    If MsgLen <> 0
      
      ; Iterate the system
      RABBIT_NextState128(*Core\Work)
      
      ; Generate 16 bytes of pseudo-random data */
      
      PokeU32(@Buffer + 00, *Core\Work\X[0] ! (*Core\Work\X[5]>>16) ! U32V(*Core\Work\X[3]<<16))
      PokeU32(@Buffer + 04, *Core\Work\X[2] ! (*Core\Work\X[7]>>16) ! U32V(*Core\Work\X[5]<<16))
      PokeU32(@Buffer + 06, *Core\Work\X[4] ! (*Core\Work\X[1]>>16) ! U32V(*Core\Work\X[7]<<16))
      PokeU32(@Buffer + 12, *Core\Work\X[6] ! (*Core\Work\X[3]>>16) ! U32V(*Core\Work\X[1]<<16))
      
      For Index = 0 To MsgLen - 1
        PokeA(*Output, PeekA(*Input) ! Buffer\Buffer[Index])
        *Output + 1
        *Input + 1
      Next
      
    EndIf
    
  EndProcedure

  Procedure RABBIT_Encrypt(*This.Private_Members, *PlainText, *CipheredText, StringByteLength.l)
    
    RABBIT_Process_Bytes128(*This\Core, *PlainText, *CipheredText, StringByteLength)
    
  EndProcedure

  Procedure RABBIT_Decrypt(*This.Private_Members, *PlainText, *CipheredText, StringByteLength.l)
    
    RABBIT_Process_Bytes128(*This\Core, *CipheredText, *PlainText, StringByteLength)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Getters <<<<<

  Procedure.s GetKey(*This.Private_Members)
    
    ProcedureReturn *This\Key
  EndProcedure
  
  Procedure.s GetInitVector(*This.Private_Members)
    
    ProcedureReturn *This\InitVector
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Setters <<<<<

  Procedure SetKey(*This.Private_Members, P_Key.s)
    
    If P_Key <> ""
      *This\Key = P_Key
    Else
      *This\Key = "RabbitCipher"
    EndIf
    
    *This\IsSetupDone = #False
    
  EndProcedure
  
  Procedure SetInitVector(*This.Private_Members, P_InitVector.s)
    
    If P_InitVector <> ""
      *This\InitVector = P_InitVector
    Else
      *This\InitVector = "InitVector"
    EndIf
    
    *This\IsSetupDone = #False
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The RunSetup operator <<<<<
  
  Procedure RunSetup(*This.Private_Members)
    
    NormKey = Normalizer(*This\Key, 128)
    RABBIT_KeySetup128(*This\Core, NormKey)
    FreeMemory(NormKey)
    
    If *This\InitVector <> "NULL"
      NormInitVec = Normalizer(*This\InitVector, 64)
      RABBIT_InitVectorSetup128(*This\Core, NormInitVec)
      FreeMemory(NormInitVec)
    EndIf
    
    *This\IsSetupDone = #True
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Write on file operators <<<<<
  
  Procedure RC_WriteString(*This.Private_Members, FileID.i, P_String.s)
    
    If *This\IsSetupDone = #True
      
      StringMemorySize.q = StringByteLength(P_String) + SizeOf(Character)
      WriteU32(FileID, StringMemorySize)
      
      *CipheredText = AllocateMemory(StringMemorySize)
      RABBIT_Encrypt(*This, @P_String, *CipheredText, StringByteLength(P_String))
      WriteData(FileID, *CipheredText, StringMemorySize)
      
      FreeMemory(*CipheredText)
      
    EndIf 
    
  EndProcedure
  
  Procedure RC_WriteByte(*This.Private_Members, FileID.i, P_Value.b)
    
    If P_Value < 0
      Sign.s = "-"
      P_Value = P_Value * -1
    EndIf
    
    RC_WriteString(*This, FileID, Sign + RSet(Str(P_Value), 6, "0"))
    
  EndProcedure
  
  Procedure RC_WriteAsciiCharacter(*This.Private_Members, FileID.i, P_Value.a)
    
    RC_WriteString(*This, FileID, RSet(Str(P_Value), 6, "0"))
    
  EndProcedure
  
  Procedure RC_WriteWord(*This.Private_Members, FileID.i, P_Value.w)
    
    If P_Value < 0
      Sign.s = "-"
      P_Value = P_Value * -1
    EndIf
    
    RC_WriteString(*This, FileID, Sign + RSet(Str(P_Value), 10, "0"))
    
  EndProcedure
  
  Procedure RC_WriteUnicodeCharacter(*This.Private_Members, FileID.i, P_Value.u)
    
    RC_WriteString(*This, FileID, RSet(Str(P_Value), 10, "0"))
    
  EndProcedure
  
  Procedure RC_WriteCharacter(*This.Private_Members, FileID.i, P_Value.c)
    
    RC_WriteString(*This, FileID, RSet(Str(P_Value), 10, "0"))
    
  EndProcedure
  
  Procedure RC_WriteLong(*This.Private_Members, FileID.i, P_Value.l)
    
    If P_Value < 0
      Sign.s = "-"
      P_Value = P_Value * -1
    EndIf
    
    RC_WriteString(*This, FileID, Sign + RSet(Str(P_Value), 22, "0"))
    
  EndProcedure
  
  Procedure RC_WriteQuad(*This.Private_Members, FileID.i, P_Value.q)
    
    If P_Value < 0
      Sign.s = "-"
      P_Value = P_Value * -1
    EndIf
    
    RC_WriteString(*This, FileID, Sign + RSet(Str(P_Value), 42, "0"))
    
  EndProcedure
  
  Procedure RC_WriteInteger(*This.Private_Members, FileID.i, P_Value.i)
    
    If P_Value < 0
      Sign.s = "-"
      P_Value = P_Value * -1
    EndIf
    
    RC_WriteString(*This, FileID, Sign + RSet(Str(P_Value), 42, "0"))
    
  EndProcedure
  
  Procedure RC_WriteFloat(*This.Private_Members, FileID.i, P_Value.f)
    
    RC_WriteString(*This, FileID, StrF(P_Value, 14))
    
  EndProcedure
  
  Procedure RC_WriteDouble(*This.Private_Members, FileID.i, P_Value.d)
    
    RC_WriteString(*This, FileID, StrD(P_Value, 25))
    
  EndProcedure
  
  Procedure RC_WriteData(*This.Private_Members, FileID.i, *Memory, Size.l) 
    
    If *This\IsSetupDone = #True
      
      If *Memory <> #Null
        
        *CipheredMemory = AllocateMemory(Size)
        RABBIT_Encrypt(*This, *Memory, *CipheredMemory, Size)
        WriteData(FileID, *CipheredMemory, Size)
        FreeMemory(*CipheredMemory)
        
      EndIf
      
    EndIf
    
  EndProcedure

  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Read on file operators <<<<<
  
  Procedure.s RC_ReadString(*This.Private_Members, FileID.i)
    
    If *This\IsSetupDone = #True
      
      StringMemorySize.q = ReadU32(FileID)
      *PlainText = AllocateMemory(StringMemorySize)
      *CipheredText = AllocateMemory(StringMemorySize)
      
      ReadData(FileID, *CipheredText, StringMemorySize)
      
      RABBIT_Decrypt(*This, *PlainText, *CipheredText, StringMemorySize - SizeOf(Character))
      DecryptedString.s = PeekS(*PlainText)
      
      FreeMemory(*PlainText)
      FreeMemory(*CipheredText)
      
    EndIf
    
    ProcedureReturn DecryptedString
  EndProcedure
  
  Procedure.b RC_ReadByte(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.a RC_ReadAsciiCharacter(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.w RC_ReadWord(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.u RC_ReadUnicodeCharacter(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.c RC_ReadCharacter(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.l RC_ReadLong(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.q RC_ReadQuad(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.i RC_ReadInteger(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.f RC_ReadFloat(*This.Private_Members, FileID.i)
    
    ProcedureReturn ValF(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.d RC_ReadDouble(*This.Private_Members, FileID.i)
    
    ProcedureReturn ValD(RC_ReadString(*This, FileID))
  EndProcedure
  
  Procedure RC_ReadData(*This.Private_Members, FileID.i, *Memory, Size.l)
    
    If *This\IsSetupDone = #True
      
      If *Memory <> #Null
        
        *CipheredMemory = AllocateMemory(Size)
        bytes = ReadData(FileID, *CipheredMemory, Size)
        RABBIT_Decrypt(*This, *Memory, *CipheredMemory, Size)
        FreeMemory(*CipheredMemory)
        
      EndIf
      
    EndIf
    
    ProcedureReturn bytes
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructor <<<<<

  Procedure.i New(P_Key.s = "RabbitCipher", P_InitVector.s = "InitVector")
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    SetKey(*This, P_Key)
    SetInitVector(*This, P_InitVector)
    RunSetup(*This)
    
    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetKey()
    Data.i @GetInitVector()
    Data.i @SetKey()
    Data.i @SetInitVector()
    Data.i @RunSetup()
    
    Data.i @RC_WriteString()
    Data.i @RC_WriteByte()
    Data.i @RC_WriteAsciiCharacter()
    Data.i @RC_WriteWord()
    Data.i @RC_WriteUnicodeCharacter()
    Data.i @RC_WriteCharacter()
    Data.i @RC_WriteLong()
    Data.i @RC_WriteQuad()
    Data.i @RC_WriteInteger()
    Data.i @RC_WriteFloat()
    Data.i @RC_WriteDouble()
    Data.i @RC_WriteData()
    
    Data.i @RC_ReadString()
    Data.i @RC_ReadByte()
    Data.i @RC_ReadAsciiCharacter()
    Data.i @RC_ReadWord()
    Data.i @RC_ReadUnicodeCharacter()
    Data.i @RC_ReadCharacter()
    Data.i @RC_ReadLong()
    Data.i @RC_ReadQuad()
    Data.i @RC_ReadInteger()
    Data.i @RC_ReadFloat()
    Data.i @RC_ReadDouble()
    Data.i @RC_ReadData()
    
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (96000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CompilerIf #PB_Compiler_IsMainFile
  
  UseMD5Fingerprint()
  RC.RabbitCipher::RabbitCipher = RabbitCipher::New()
  
  Varw.w = 32700
  Varl.l = -2147483645
  Varq.q = 9223372036854775800
  Varf.f = 2 * #PI
  Vard.d = 3 * #PI
  Text.s = "J'aime les déesses nordiques super sexy !"
  
  Buffer.i = AllocateMemory(10 * SizeOf(Long))
  FillMemory(Buffer, MemorySize(Buffer), -255, #PB_Long)
  
  Debug "; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
  Debug "; Test on file"
  Debug ""
  Debug "Original : "
  
  Debug Varw
  Debug Varl
  Debug Varq
  Debug Varf
  Debug Vard
  Debug Text
  Debug ""
  
  If CreateFile(0, "Test.rc")
    
    RC\SetKey("PureBasic 6.00") ; Set the key
    RC\SetInitVector("") ; Restore the default Init vector
    RC\RunSetup()
    
    RC\RC_WriteWord(0, Varw) 
    RC\RC_WriteLong(0, Varl)  
    RC\RC_WriteQuad(0, Varq)
    
    RC\SetKey("") ; Restore the default key
    RC\SetInitVector("NULL") ; No Init vector here
    RC\RunSetup()
    
    RC\RC_WriteFloat(0, Varf)
    RC\RC_WriteDouble(0, Vard)
    RC\RC_WriteString(0, Text)
    
    RC\RC_WriteLong(0, MemorySize(Buffer))
    RC\RC_WriteData(0, Buffer, MemorySize(Buffer))
    
    CloseFile(0)
    
  EndIf 
  
  Debug "FileSize : " + Str(FileSize("Test.rc")) 
  Debug "From the file : " 
  
  If ReadFile(1, "Test.rc")
    
    RC\SetKey("PureBasic 6.00") ; Set the key
    RC\SetInitVector("") ; Restore the default Init vector
    RC\RunSetup()
    
    Debug RC\RC_ReadWord(1)
    Debug RC\RC_ReadLong(1)
    Debug RC\RC_ReadQuad(1)
    
    RC\SetKey("") ; Restore the default key
    RC\SetInitVector("NULL")  ; No Init vector here
    RC\RunSetup()
    
    Debug RC\RC_ReadFloat(1)
    Debug RC\RC_ReadDouble(1)
    Debug RC\RC_ReadString(1)
    
    MemorySize.l = RC\RC_Readlong(1)
    
    Buffer2 = AllocateMemory(MemorySize)
    RC\RC_ReadData(1, Buffer2, MemorySize)
    
    Debug "Compare Buffer vs Buffer2 (0 = KO, 1 = OK) -> " + Str(CompareMemory(Buffer, Buffer2, MemorySize))
    
    CloseFile(1)
    DeleteFile("Test.rc")
    
  EndIf 
  
  RC\Free()
  
CompilerEndIf

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.00 Beta 1 (Linux - x64)
; Folding = ----------
; EnableXP
; CompileSourceDirectory
; Compiler = PureBasic 6.00 Beta 1 - C Backend (Linux - x64)