; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V1.1.0
; Project name : Read Write XTEA
; File name : Read Write XTEA - OOP.pb
; File Version : 1.2.2
; Programmation : OK
; Programmed by : StarBootics
; Creation Date : October 25th, 2020
; Last update : November 27th, 2021
; Coded for PureBasic : V6.00 Beta 1
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule XTEA
  
  Interface XTEA
    
    GetKey.s()
    GetRounds.l()
    SetKey(Key.s)
    SetRounds(Rounds.l)
    
    XTEA_WriteString(FileID.i, String.s)
    XTEA_WriteByte(FileID.i, Value.b)
    XTEA_WriteAsciiCharacter(FileID.i, Value.a)
    XTEA_WriteWord(FileID.i, Value.w)
    XTEA_WriteUnicodeCharacter(FileID.i, Value.u)
    XTEA_WriteCharacter(FileID.i, Value.c)
    XTEA_WriteLong(FileID.i, Value.l)
    XTEA_WriteQuad(FileID.i, Value.q)
    XTEA_WriteInteger(FileID.i, Value.i)
    XTEA_WriteFloat(FileID.i, Value.f)
    XTEA_WriteDouble(FileID.i, Value.d)
    XTEA_WriteData(FileID.i, *Memory, Size.l)
    
    XTEA_ReadString.s(FileID.i)
    XTEA_ReadByte.b(FileID.i)
    XTEA_ReadAsciiCharacter.a(FileID.i)
    XTEA_ReadWord.w(FileID.i)
    XTEA_ReadUnicodeCharacter.u(FileID.i)
    XTEA_ReadCharacter.c(FileID.i)
    XTEA_ReadLong.l(FileID.i)
    XTEA_ReadQuad.q(FileID.i)
    XTEA_ReadInteger.i(FileID.i)
    XTEA_ReadFloat.f(FileID.i)
    XTEA_ReadDouble.d(FileID.i)
    XTEA_ReadData(FileID.i, *Memory, Size.l)
    
    Free()
    
  EndInterface
  
  Declare.i New(Key.s = "XTEA", Rounds.l = 64)
  
EndDeclareModule

Module XTEA
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Constant declaration <<<<<
  
  #DELTA = 2654435769
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structures decleration <<<<<

  Structure Key
    
    Values.q[4]
    
  EndStructure  
  
  Structure Private_Members
    
    VirtualTable.i
    Key.s
    Rounds.l
    NormalizedKey.Key
    
  EndStructure
  
  Structure Block
    
    Values.q[2]
    
  EndStructure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Procedure definition (Private) <<<<<
  
  Macro U32V(v)
    
    ((v) & $FFFFFFFF)
    
  EndMacro
  
  Procedure.q Addition(VarA.q, VarB.q)
   
    ProcedureReturn U32V(VarA + VarB)
  EndProcedure
  
  Procedure.q Substraction(VarA.q, VarB.q)
    
    ProcedureReturn U32V(VarA - VarB)
  EndProcedure
  
  Procedure.q ReadU32(FileID.i)
    
    ReadData(FileID, @Var.q, 4)
    
    ProcedureReturn Var
  EndProcedure
  
  Procedure WriteU32(FileID.i, Var.q)
    
    WriteData(FileID, @Var, 4)
    
  EndProcedure
  
  Procedure Private_Encrypt(*This.Private_Members, *Block.Block)
    
    Sum.q = 0
    
    For RoundID = 0 To *This\Rounds - 1
      
      Temp00.q = U32V(*Block\Values[1] << 4) ! *Block\Values[1] >> 5 
      Temp01.q = Addition(Temp00, *Block\Values[1])
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_x86
        IndexA.i = Sum & 3
        Temp02.q = Addition(Sum, *This\NormalizedKey\Values[IndexA])
      CompilerElse
        Temp02.q = Addition(Sum, *This\NormalizedKey\Values[Sum & 3])
      CompilerEndIf

      *Block\Values[0] = Addition(*Block\Values[0], Temp01 ! Temp02)
      
      Sum = Addition(Sum, #DELTA) 
      
      Temp03.q = U32V(*Block\Values[0] << 4) ! *Block\Values[0] >> 5
      Temp04.q = Addition(Temp03, *Block\Values[0])
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_x86
        IndexB.i = (Sum>>11) & 3
        Temp05.q = Addition(Sum, *This\NormalizedKey\Values[IndexB])
      CompilerElse
        Temp05.q = Addition(Sum, *This\NormalizedKey\Values[(Sum>>11) & 3])
      CompilerEndIf

      *Block\Values[1] = Addition(*Block\Values[1], Temp04 ! Temp05)
      
    Next
    
  EndProcedure
  
  Procedure Private_Decrypt(*This.Private_Members, *Block.Block)
    
    Sum.q = U32V(*This\Rounds * #DELTA)
    
    For RoundID = 0 To *This\Rounds - 1
      
      Temp00.q = U32V(*Block\Values[0] << 4) ! *Block\Values[0] >> 5
      Temp01.q = Addition(Temp00, *Block\Values[0])
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_x86
        IndexA.i = (Sum >> 11) & 3
        Temp02.q = Addition(Sum, *This\NormalizedKey\Values[IndexA])
      CompilerElse
        Temp02.q = Addition(Sum, *This\NormalizedKey\Values[(Sum >> 11) & 3])
      CompilerEndIf

      *Block\Values[1] = Substraction(*Block\Values[1], Temp01 ! Temp02)
      Sum = Substraction(Sum, #DELTA) 
      
      Temp03.q = U32V(*Block\Values[1] << 4) ! *Block\Values[1] >> 5
      Temp04.q = Addition(Temp03, *Block\Values[1])
      
      CompilerIf #PB_Compiler_Processor = #PB_Processor_x86
        IndexB.i = Sum & 3
        Temp05.q = Addition(Sum, *This\NormalizedKey\Values[IndexB])
      CompilerElse
        Temp05.q = Addition(Sum, *This\NormalizedKey\Values[Sum & 3])
      CompilerEndIf
      
      *Block\Values[0] = Substraction(*Block\Values[0], Temp04 ! Temp05)
      
    Next
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The getters <<<<<

  Procedure.s GetKey(*This.Private_Members)
    
    ProcedureReturn *This\Key
  EndProcedure
  
  Procedure.l GetRounds(*This.Private_Members)
    
    ProcedureReturn *This\Rounds
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The setters <<<<<

  Procedure SetKey(*This.Private_Members, Key.s)
    
    If Key <> ""
      *This\Key = Key
    Else
      *This\Key = "XTEA"
    EndIf
    
    Output.s = StringFingerprint(*This\Key, #PB_Cipher_MD5)
    
    B00.a = Val("$" + Mid(Output, 01, 2))
    B01.a = Val("$" + Mid(Output, 02, 2))
    B02.a = Val("$" + Mid(Output, 03, 2))
    B03.a = Val("$" + Mid(Output, 04, 2))
    B04.a = Val("$" + Mid(Output, 05, 2))
    B05.a = Val("$" + Mid(Output, 06, 2))
    B06.a = Val("$" + Mid(Output, 07, 2))
    B07.a = Val("$" + Mid(Output, 08, 2))
    B08.a = Val("$" + Mid(Output, 09, 2))
    B09.a = Val("$" + Mid(Output, 10, 2))
    B10.a = Val("$" + Mid(Output, 11, 2))
    B11.a = Val("$" + Mid(Output, 12, 2))
    B12.a = Val("$" + Mid(Output, 13, 2))
    B13.a = Val("$" + Mid(Output, 14, 2))
    B14.a = Val("$" + Mid(Output, 15, 2))
    B15.a = Val("$" + Mid(Output, 16, 2))
    
    *This\NormalizedKey\Values[0] = U32V(B00 | B01 << 8 | B02 << 16 | B03 << 24)
    *This\NormalizedKey\Values[1] = U32V(B04 | B05 << 8 | B06 << 16 | B07 << 24)
    *This\NormalizedKey\Values[2] = U32V(B08 | B09 << 8 | B10 << 16 | B11 << 24)
    *This\NormalizedKey\Values[3] = U32V(B12 | B13 << 8 | B14 << 16 | B15 << 24)
    
  EndProcedure
  
  Procedure SetRounds(*This.Private_Members, Rounds.l)
    
    Select Rounds
        
      Case 32, 64, 128, 256, 512
        *This\Rounds = Rounds
        
      Default
        *This\Rounds = 64
        
    EndSelect
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Write on file operators <<<<<
  
  Procedure XTEA_WriteString(*This.Private_Members, FileID.i, String.s)
    
    Protected Block.Block
    
    CharMax = Len(String)
    WriteU32(FileID, CharMax)
    
    For CharID = 1 To CharMax Step 4
      
      Block\Values[0] = Asc(Mid(String, CharID + 0, 1)) << 16 | Asc(Mid(String, CharID + 1, 1))
      Block\Values[1] = Asc(Mid(String, CharID + 2, 1)) << 16 | Asc(Mid(String, CharID + 3, 1))
      
      Private_Encrypt(*This, Block)
      
      WriteU32(FileID, Block\Values[0])
      WriteU32(FileID, Block\Values[1])
      
    Next
    
  EndProcedure
  
  Procedure XTEA_WriteByte(*This.Private_Members, FileID.i, Value.b)
    
    If Value < 0
      Sign.s = "-"
      Value = Value * -1
    EndIf
    
    XTEA_WriteString(*This, FileID, Sign + RSet(Str(Value), 6, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteAsciiCharacter(*This.Private_Members, FileID.i, Value.a)
    
    XTEA_WriteString(*This, FileID, RSet(Str(Value), 6, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteWord(*This.Private_Members, FileID.i, Value.w)
    
    If Value < 0
      Sign.s = "-"
      Value = Value * -1
    EndIf
    
    XTEA_WriteString(*This, FileID, Sign + RSet(Str(Value), 10, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteCharacter(*This.Private_Members, FileID.i, Value.c)
    
    XTEA_WriteString(*This, FileID, RSet(Str(Value), 10, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteUnicodeCharacter(*This.Private_Members, FileID.i, Value.u)
    
    XTEA_WriteString(*This, FileID, RSet(Str(Value), 10, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteLong(*This.Private_Members, FileID.i, Value.l)
    
    If Value < 0
      Sign.s = "-"
      Value = Value * -1
    EndIf
    
    XTEA_WriteString(*This, FileID, Sign + RSet(Str(Value), 22, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteQuad(*This.Private_Members, FileID.i, Value.q)
    
    If Value < 0
      Sign.s = "-"
      Value = Value * -1
    EndIf
    
    XTEA_WriteString(*This, FileID, Sign + RSet(Str(Value), 42, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteInteger(*This.Private_Members, FileID.i, Value.i)
    
    If Value < 0
      Sign.s = "-"
      Value = Value * -1
    EndIf
    
    XTEA_WriteString(*This, FileID, Sign + RSet(Str(Value), 42, "0"))
    
  EndProcedure
  
  Procedure XTEA_WriteFloat(*This.Private_Members, FileID.i, Value.f)
    
    XTEA_WriteString(*This, FileID, StrF(Value, 14))
    
  EndProcedure
  
  Procedure XTEA_WriteDouble(*This.Private_Members, FileID.i, Value.d)
    
    XTEA_WriteString(*This, FileID, StrD(Value, 25))
    
  EndProcedure
  
  Procedure XTEA_WriteData(*This.Private_Members, FileID.i, *Memory, Size.l)
    
    Protected Block.Block
    
    While Size >= 8
      
      Block\Values[0] = PeekU(*Memory + 0) << 16 | PeekU(*Memory + 2)
      Block\Values[1] = PeekU(*Memory + 4) << 16 | PeekU(*Memory + 6)
      
      *Memory + 8
      Size - 8
      
      Private_Encrypt(*This, Block)
      
      WriteU32(FileID, Block\Values[0])
      WriteU32(FileID, Block\Values[1])
      
    Wend
    
    If Size <> 0
      
      Select Size
          
        Case 7
          Block\Values[0] = PeekU(*Memory + 0) << 16 | PeekU(*Memory + 2)
          Block\Values[1] = PeekU(*Memory + 4) << 16 | PeekA(*Memory + 6)
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
        Case 6
          Block\Values[0] = PeekU(*Memory + 0) << 16 | PeekU(*Memory + 2)
          Block\Values[1] = PeekA(*Memory + 4) << 16 | PeekA(*Memory + 5)
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
        Case 5
          Block\Values[0] = PeekU(*Memory + 0) << 16 | PeekA(*Memory + 2)
          Block\Values[1] = PeekA(*Memory + 3) << 16 | PeekA(*Memory + 4)
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
        Case 4  
          Block\Values[0] = PeekA(*Memory + 0) << 16 | PeekA(*Memory + 1)
          Block\Values[1] = PeekA(*Memory + 2) << 16 | PeekA(*Memory + 3)
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
        Case 3
          Block\Values[0] = PeekA(*Memory + 0) << 16 | PeekA(*Memory + 1)
          Block\Values[1] = PeekA(*Memory + 2) << 16 | 0
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
        Case 2
          Block\Values[0] = PeekA(*Memory + 0) << 16 | PeekA(*Memory + 1)
          Block\Values[1] = 0
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
        Case 1
          Block\Values[0] = PeekA(*Memory + 0) << 16 | 0
          Block\Values[1] = 0
          Private_Encrypt(*This, Block)
          
          WriteU32(FileID, Block\Values[0])
          WriteU32(FileID, Block\Values[1])
          
      EndSelect
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Read on file operators <<<<<
  
  Procedure.s XTEA_ReadString(*This.Private_Members, FileID.i)
    
    Protected Block.Block
    
    CharMax = ReadU32(FileID)
    
    For CharID = 1 To CharMax Step 4
      
      Block\Values[0] = ReadU32(FileID)
      Block\Values[1] = ReadU32(FileID)
      
      Private_Decrypt(*This, Block)
      
      Output.s + Chr((Block\Values[0] >> 16) & $FFFF) + Chr(Block\Values[0] & $FFFF)
      Output.s + Chr((Block\Values[1] >> 16) & $FFFF) + Chr(Block\Values[1] & $FFFF)
      
    Next
    
    ProcedureReturn Output
  EndProcedure
  
  Procedure.b XTEA_ReadByte(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.a XTEA_ReadAsciiCharacter(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.w XTEA_ReadWord(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.c XTEA_ReadCharacter(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.u XTEA_ReadUnicodeCharacter(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.l XTEA_ReadLong(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.q XTEA_ReadQuad(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.i XTEA_ReadInteger(*This.Private_Members, FileID.i)
    
    ProcedureReturn Val(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.f XTEA_ReadFloat(*This.Private_Members, FileID.i)
    
    ProcedureReturn ValF(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure.d XTEA_ReadDouble(*This.Private_Members, FileID.i)
    
    ProcedureReturn ValD(XTEA_ReadString(*This, FileID))
  EndProcedure
  
  Procedure XTEA_ReadData(*This.Private_Members, FileID.i, *Memory, Size.l)
    
    Protected Block.Block
    
    While Size >= 8
      
      Block\Values[0] = ReadU32(FileID)
      Block\Values[1] = ReadU32(FileID)
      
      Private_Decrypt(*This, Block)
      
      PokeU(*Memory + 0, (Block\Values[0] >> 16) & $FFFF)
      PokeU(*Memory + 2, Block\Values[0] & $FFFF)
      PokeU(*Memory + 4, (Block\Values[1] >> 16) & $FFFF)
      PokeU(*Memory + 6, Block\Values[1] & $FFFF)
      
      *Memory + 8
      Size - 8
      
    Wend
    
    If Size <> 0
      
      Select Size
          
        Case 7
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          
          PokeU(*Memory + 0, (Block\Values[0] >> 16) & $FFFF)
          PokeU(*Memory + 2, Block\Values[0] & $FFFF)
          PokeU(*Memory + 4, (Block\Values[1] >> 16) & $FFFF)
          PokeA(*Memory + 6, Block\Values[1] & $FF)
          
        Case 6
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          
          PokeU(*Memory + 0, (Block\Values[0] >> 16) & $FFFF)
          PokeU(*Memory + 2, Block\Values[0] & $FFFF)
          PokeA(*Memory + 4, (Block\Values[1] >> 16) & $FF)
          PokeA(*Memory + 5, Block\Values[1] & $FF)
          
        Case 5
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          
          PokeU(*Memory + 0, (Block\Values[0] >> 16) & $FFFF)
          PokeA(*Memory + 2, Block\Values[0] & $FF)
          PokeA(*Memory + 3, (Block\Values[1] >> 16) & $FF)
          PokeA(*Memory + 4, Block\Values[1] & $FF)
          
        Case 4  
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          
          PokeA(*Memory + 0, (Block\Values[0] >> 16) & $FF)
          PokeA(*Memory + 1, Block\Values[0] & $FF)
          PokeA(*Memory + 2, (Block\Values[1] >> 16) & $FF)
          PokeA(*Memory + 3, Block\Values[1] & $FF)
          
        Case 3
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          
          PokeA(*Memory + 0, (Block\Values[0] >> 16) & $FF)
          PokeA(*Memory + 1, Block\Values[0] & $FF)
          PokeA(*Memory + 2, (Block\Values[1] >> 16) & $FF)
          
        Case 2
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          
          PokeA(*Memory + 0, (Block\Values[0] >> 16) & $FF)
          PokeA(*Memory + 1, Block\Values[0] & $FF)
          
        Case 1
          Block\Values[0] = ReadU32(FileID)
          Block\Values[1] = ReadU32(FileID)
          
          Private_Decrypt(*This, Block)
          PokeA(*Memory + 0, (Block\Values[0] >> 16) & $FF)
          
      EndSelect
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructor <<<<<

  Procedure.i New(Key.s = "XTEA", Rounds.l = 64)
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    SetKey(*This, Key)
    SetRounds(*This, Rounds)
    
    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetKey()
    Data.i @GetRounds()
    Data.i @SetKey()
    Data.i @SetRounds()
    Data.i @XTEA_WriteString()
    Data.i @XTEA_WriteByte()
    Data.i @XTEA_WriteAsciiCharacter()
    Data.i @XTEA_WriteWord()
    Data.i @XTEA_WriteUnicodeCharacter()
    Data.i @XTEA_WriteCharacter()
    Data.i @XTEA_WriteLong()
    Data.i @XTEA_WriteQuad()
    Data.i @XTEA_WriteInteger()
    Data.i @XTEA_WriteFloat()
    Data.i @XTEA_WriteDouble()
    Data.i @XTEA_WriteData()
    Data.i @XTEA_ReadString()
    Data.i @XTEA_ReadByte()
    Data.i @XTEA_ReadAsciiCharacter()
    Data.i @XTEA_ReadWord()
    Data.i @XTEA_ReadUnicodeCharacter()
    Data.i @XTEA_ReadCharacter()
    Data.i @XTEA_ReadLong()
    Data.i @XTEA_ReadQuad()
    Data.i @XTEA_ReadInteger()
    Data.i @XTEA_ReadFloat()
    Data.i @XTEA_ReadDouble()
    Data.i @XTEA_ReadData()
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (114000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CompilerIf #PB_Compiler_IsMainFile
  
  UseMD5Fingerprint()
  XTEA.XTEA::XTEA = XTEA::New()
  
  Varw.w = 32700
  Varl.l = -2147483645
  Varq.q = 9223372036854775800
  Varf.f = 2 * #PI
  Vard.d = 3 * #PI
  Text.s = "J'aime les déesses nordiques super sexy !!!!!"
  
  Buffer.i = AllocateMemory(100 * SizeOf(Long))
  FillMemory(Buffer, MemorySize(Buffer), -100125, #PB_Long)
  
  Debug "; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
  Debug "; Test on file"
  Debug ""
  Debug "Original : "
  
  Debug Varw
  Debug Varl
  Debug Varq
  Debug Varf
  Debug Vard
  Debug Text
  Debug ""
  
  If CreateFile(0, "Test.xtea")
    
    XTEA\SetKey("PURE")
    XTEA\SetRounds(256)
    
    XTEA\XTEA_WriteWord(0, Varw) 
    XTEA\XTEA_WriteLong(0, Varl)  
    XTEA\XTEA_WriteQuad(0, Varq)
    
    XTEA\SetKey("XTEA")
    XTEA\SetRounds(512)
    
    XTEA\XTEA_WriteFloat(0, Varf)
    XTEA\XTEA_WriteDouble(0, Vard)
    XTEA\XTEA_WriteString(0, Text)
    
    XTEA\XTEA_WriteLong(0, MemorySize(Buffer))
    XTEA\XTEA_WriteData(0, Buffer, MemorySize(Buffer))
    
    CloseFile(0)
    
  EndIf 
  
  Debug "File size : " + Str(FileSize("Test.xtea")) + " bytes" 
  Debug "From file : " 
  
  If ReadFile(1, "Test.xtea")
    
    XTEA\SetKey("PURE")
    XTEA\SetRounds(256)
    
    Debug XTEA\XTEA_ReadWord(1)
    Debug XTEA\XTEA_ReadLong(1)
    Debug XTEA\XTEA_ReadQuad(1)
    
    XTEA\SetKey("XTEA")
    XTEA\SetRounds(512)
    
    Debug XTEA\XTEA_ReadFloat(1)
    Debug XTEA\XTEA_ReadDouble(1)
    Debug XTEA\XTEA_ReadString(1)
    
    MemorySize.l = XTEA\XTEA_Readlong(1)
    
    Buffer2 = AllocateMemory(MemorySize)
    XTEA\XTEA_ReadData(1, Buffer2, MemorySize)
    
    Debug "Compare Buffer vs Buffer2 -> (0=KO, 1=OK) -> " + Str(CompareMemory(Buffer, Buffer2, MemorySize))
    
    CloseFile(1)
    DeleteFile("Test.xtea")
    
  EndIf 
  
  XTEA\Free()
  
CompilerEndIf

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.00 Beta 1 (Linux - x64)
; Folding = ---------
; EnableXP
; CompileSourceDirectory
; Compiler = PureBasic 6.00 Beta 1 - C Backend (Linux - x64)